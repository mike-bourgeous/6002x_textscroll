<!DOCTYPE html>
<html>
	<head>
		<title>Foundations of Analog and Digital Electronic Circuits - Agarwal, Lang</title>
		<style type="text/css">
			body {
				background: #ccc;
				color: #111;
			}
			section.page {
				background: #fff;
			}
		</style>
		<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
		<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jqueryui/1.8.18/jquery-ui.min.js"></script>
	</head>
	<body>
		<section class="main-content">
			<section class="book">
				<section class="page">
				Textbook content goes here.
				</section>
			</section>
		</secton>

		<script type="text/javascript">
			// Scrollable MITx 6.002x textbook
			// A quick hack by Mike Bourgeous (nitrogenaudio.com/contact.html)

			var SCR_TXT = {
				// Book structure settings
				firstPage: 0, // First physical page number (i.e. number of first image)
				lastPage: 1008, // Number of last image
				pageOne: 25, // Physical page number of page 1
				pageDigits: 3, // Minimum number of digits in image filenames
				pageWidth: 960, // Width of a page in pixels
				pageHeight: 1080, // Height of a page in pixels
				urlPrefix: window.location.search.substring(1),
				urlSuffix: '.png',

				// Network behavior settings
				pagesBefore: 1, // Number of pages to load before the current page (should be >= 1)
				totalPages: 4, // Total number of pages to keep loaded
				loadInterval: 150, // Minimum number of milliseconds to wait between page loads
			};

			// Namespace pollution avoidance wrapper for scrollable textbook initialization.
			$(function() {
				// Pads nbr to at least the given number of digits using leading zeros.
				SCR_TXT.zeroPad = function(nbr, digits) {
					var zeros = digits - nbr.toString().length;
					var str = '';

					for(var i = 0; i < zeros; i++) {
						str += '0';
					}
					str += nbr.toString();

					return str;
				}

				// Excludes values in range1 from range2, operating under the assumption that
				// neither range will entirely enclose the other, with leftover elements on
				// both ends.  Range1 and range2 should both be two-numeric-element arrays.
				// The original arrays are not modified.
				// Example: SCR_TXT.excludeRange([15, 20], [19, 24]) returns [21, 24].
				SCR_TXT.excludeRange = function(range1, range2) {
					var min1 = range1[0];
					var max1 = range1[1];
					var min2 = range2[0];
					var max2 = range2[1];

					if(max1 < min2 || min1 > max2) {
						// range1 and range2 do not overlap
						return range2;
					}

					if(min1 <= min2 && max1 >= max2) {
						// range1 entirely eliminates range2
						min2 = -1;
						max2 = -1;
					} else if(max1 >= min2 && min1 <= min2) {
						// range1 chops elements off the beginning of range2
						min2 = max1 + 1;
					} else if(min1 <= max2 && max1 >= max2) {
						// range1 chops elements off the end of range2
						max2 = min1 - 1;
					} else {
						// range1 lies within range2, creating an invalid split
						throw 'Range2 encloses range1: [' + range1.join(', ') + '] and ['
							+ range2.join(', ') + '] -- unable to split range';
					}

					return [min2, max2];
				}

				// Creates an unloaded img tag for the given page number.
				SCR_TXT.makeImage = function(pageno) {
					var pageStr = SCR_TXT.zeroPad(pageno, SCR_TXT.pageDigits);
					var image = document.createElement('img');
					$(image).attr('id', 'page_' + pageno)
						.attr('alt', 'Page ' + (pageno - SCR_TXT.pageOne + 1))
						.attr('data-src', '' + SCR_TXT.urlPrefix + pageStr + SCR_TXT.urlSuffix)
						.css('width', '' + (SCR_TXT.pageWidth) + 'px')
						.css('height', '' + (SCR_TXT.pageHeight) + 'px')
						.css('margin', '0')
						.css('display', 'inline-block')
						.css('padding', '0');
					return image;
				}

				// Creates a section with unloaded img tag for the given page number.
				SCR_TXT.makePage = function(pageno) {
					var section = document.createElement('section');
					$(section).attr('class', 'page')
						.css('width', '' + (SCR_TXT.pageWidth) + 'px')
						.css('height', '' + (SCR_TXT.pageHeight) + 'px')
						.css('border', 'solid 1px black')
						.css('margin', '10px auto')
						.css('padding', '10px')
						.html(SCR_TXT.makeImage(pageno));
					return section;
				}

				// Returns the currently visible page number based on scroll bar position.
				// Includes fractional page amount.
				SCR_TXT.currentPage = function() {
					var offset = $(document).scrollTop() + $(window).height() / 2 - SCR_TXT.scrollStart;
					var pageno = offset / SCR_TXT.scrollOffset + SCR_TXT.firstPage;

					return Math.min(Math.max(pageno, SCR_TXT.firstPage), SCR_TXT.lastPage);
				}

				// Returns the integer logical page number of the currently visible page.
				SCR_TXT.currentLogicalPage = function() {
					return Math.floor(SCR_TXT.currentPage() - SCR_TXT.pageOne + 1);
				}

				// Returns the minimum and maximum pages to load, inclusive.
				// If pageno is unspecified, the current page will be used.
				SCR_TXT.pageRange = function(pageno) {
					pageno = pageno || SCR_TXT.currentPage();
					var minPage = Math.floor(pageno) - SCR_TXT.pagesBefore;
					var maxPage = minPage + SCR_TXT.totalPages - 1;

					minPage = Math.min(Math.max(minPage, SCR_TXT.firstPage), SCR_TXT.lastPage);
					maxPage = Math.min(Math.max(maxPage, SCR_TXT.firstPage), SCR_TXT.lastPage);

					return [minPage, maxPage];
				}

				// Loads the pages within the specified range, inclusive.  The range
				// may be specified as a two-element integer array passed in min.
				SCR_TXT.loadPages = function(min, max) {
					if(min instanceof Array) {
						max = min[1];
						min = min[0];
					}

					for(var i = min; i <= max; i++) {
						var img = $(SCR_TXT.pages[i - SCR_TXT.firstPage]).find('img');
						img.attr('src', img.attr('data-src'))
							.css('border', 'solid 1px #ccc');
					}
				}

				// Unloads the pages within the specified range, inclusive.  The range
				// may be specified as a two-element integer array passed in min.
				SCR_TXT.unloadPages = function(min, max) {
					if(min instanceof Array) {
						max = min[1];
						min = min[0]
					}

					for(var i = min; i <= max; i++) {
						var page = $(SCR_TXT.pages[i - SCR_TXT.firstPage]);
						page.html(SCR_TXT.makeImage(i))
					}
				}

				// Scrolls to the top of the given page
				SCR_TXT.scrollToPage = function(pageno) {
					$(document).scrollTop($(SCR_TXT.pages[pageno - SCR_TXT.firstPage]).offset().top - 10);
				}

				// Loads and unloads pages in a timer set by SCR_TXT.updateScroll().
				SCR_TXT.loadNewPages = function() {
					var pageno = SCR_TXT.currentPage();
					var oldRange = SCR_TXT.lastPagerange || [-1, -1];
					var newRange = SCR_TXT.pageRange(pageno);
					var unloadRange = SCR_TXT.excludeRange(newRange, oldRange);
					var loadRange = SCR_TXT.excludeRange(oldRange, newRange);

					console.log("Previous range: " + oldRange);
					console.log("New range: " + newRange);
					console.log("Pages to unload: " + unloadRange);
					console.log("Pages to load: " + loadRange);

					SCR_TXT.unloadPages(unloadRange);
					SCR_TXT.loadPages(loadRange);

					SCR_TXT.lastPageno = pageno;
					SCR_TXT.lastPagerange = newRange;
				}

				// Schedules loading and unloading of pages based on the current scroll position.
				var pageLoadTimer;
				SCR_TXT.updateScroll = function() {
					var pageno = SCR_TXT.currentPage();
					console.log("XXX: Current page is " + pageno);

					if(Math.floor(pageno) != Math.floor(SCR_TXT.lastPageno)) {
						console.log("Integer page number " + Math.floor(pageno) + " differs from previous: " + Math.floor(SCR_TXT.lastPageno));

						if(pageLoadTimer) {
							clearTimeout(pageLoadTimer);
						}
						pageLoadTimer = setTimeout(SCR_TXT.loadNewPages, SCR_TXT.loadInterval);
					}
				}

				// Initializes the Infinite Scrolling Textbook.  Creates DOM elements
				// for every page, sets scroll handlers to load visible pages.
				SCR_TXT.init = function() {
					var container = $('section.page, section.page-container')
						.first().attr('class', 'page-container')
						.text('');

					SCR_TXT.pages = [];
					for(var i = SCR_TXT.firstPage; i <= SCR_TXT.lastPage; i++) {
						SCR_TXT.pages[i - SCR_TXT.firstPage] = SCR_TXT.makePage(i);
						container.append(SCR_TXT.pages[i]);
					}

					SCR_TXT.scrollStart = $(SCR_TXT.pages[0]).offset().top;
					SCR_TXT.scrollOffset = $(SCR_TXT.pages[1]).offset().top - SCR_TXT.scrollStart;

					$(document).scroll(SCR_TXT.updateScroll);
					SCR_TXT.updateScroll();
				}

				SCR_TXT.init();

				// Hook into the existing page selection functions so the side panel
				// bookmarks work.
				var old_goto_page = window.goto_page;
				window.goto_page = function(pageno) {
					if(old_goto_page) {
						old_goto_page(pageno);
					}

					SCR_TXT.scrollToPage(pageno);
				}
			});
		</script>
	</body>
</html>
